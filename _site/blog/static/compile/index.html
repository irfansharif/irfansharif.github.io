
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Compilers &amp; Recursion</title>
    <meta name="description" content="">

    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="shortcut icon" href="../favicon.ico">

    <link rel="stylesheet" type="text/css" href="../assets/css/screen-d8ea7c81.css?v=2fcbd9b980">
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic%7COpen+Sans:700,400">

    <link rel="canonical" href="index.html">
    <meta name="referrer" content="origin">
    
    <meta property="og:site_name" content="λ">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Compilers &amp; Recursion">
    <meta property="og:description" content="What's computable by a recursive model is computable by an iterative one and vice versa. One of the implications of the Church-Turing thesis is that any recursive function can be re-implemented in an iterative manner, easy to realize if we...">
    <meta property="og:url" content="http://localhost:2368/compile/">
    <meta property="article:published_time" content="2015-12-28T03:04:49.161Z">
    <meta property="article:modified_time" content="2015-12-28T03:04:49.155Z">
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Compilers &amp; Recursion">
    <meta name="twitter:description" content="What's computable by a recursive model is computable by an iterative one and vice versa. One of the implications of the Church-Turing thesis is that any recursive function can be re-implemented in an iterative manner, easy to realize if we...">
    <meta name="twitter:url" content="http://localhost:2368/compile/">
    
    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Article",
    "publisher": "λ",
    "author": {
        "@type": "Person",
        "name": "Irfan Sharif",
        "image": "http://localhost:2368/content/images/2015/12/2014-08-24-03-00-45.png",
        "url": "http://localhost:2368/author/irfan",
        "sameAs": "http://irfansharif.com",
        "description": null
    },
    "headline": "Compilers &amp; Recursion",
    "url": "http://localhost:2368/compile/",
    "datePublished": "2015-12-28T03:04:49.161Z",
    "dateModified": "2015-12-28T03:04:49.155Z",
    "description": "What&#x27;s computable by a recursive model is computable by an iterative one and vice versa. One of the implications of the Church-Turing thesis is that any recursive function can be re-implemented in an iterative manner, easy to realize if we..."
}
    </script>

    <meta name="generator" content="Ghost 0.7">
    <link rel="alternate" type="application/rss+xml" title="λ" href="../rss/index.html">
</head>
<body class="post-template nav-closed">

    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="index.html#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
            <li class="nav-home" role="presentation"><a href="../">Home</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="../rss/index.rss">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        


<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
            <a class="menu-button icon-menu" href="index.html#"><span class="word">Menu</span></a>
    </nav>
</header>

<main class="content" role="main">
    <article class="post">

        <header class="post-header">
            <h1 class="post-title">Compilers &amp; Recursion</h1>
            <section class="post-meta">
                <time class="post-date" datetime="2015-12-27">27 December 2015</time> 
            </section>
        </header>

        <section class="post-content">
            <p>What's computable by a recursive model is computable by an iterative one and vice versa. One of the implications of the <strong>Church-Turing</strong> thesis is that <em>any</em> recursive function can be re-implemented in an iterative manner, easy to realize if we consider the callstack in memory to be emulated within the recursive procedure itself.</p>

<p>One of the very many challenges faced when designing a compiler is according it the ability to compile recursive programs into machine code. We will now explore the procedure of <em>stripping</em> out the recursion within a given recursive procedure considering the following recursive implementation of a preorder traversal:</p>

<pre><code class="language-prettyprint lang-cpp">void traverse(Node* node)  
{
    if ( node ) {
        visit( node );
        traverse( node-&gt;left );
        traverse( node-&gt;right );
    }
}
</code></pre>

<p><em>End-recursion removal</em>, as the name suggests, is the systematic removal of the recursive call at the end of a procedure with no code following it. As in the case above, the second call to <code>traverse</code> is made with <code>node-&gt;right</code>, when that call is completed the current invocation of <code>traverse</code> is also completed. This same sequence of events can however be emulated using a <code>goto</code> instead giving us the following:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{

 l: if ( node ) {
        visit( node );
        traverse( node-&gt;left );
        node = node-&gt;right;
        goto l;
    }
}
</code></pre>

<p>Removing the second recursive call is slightly more tedious in having to take the approach as stated above where we emulate the callstack within the procedure itself. Most compilers use the following sequence of actions:</p>

<ol>
<li>Save current state (current values of local variables)  </li>
<li>Save the address of the next instruction (i.e. the instruction directly after the recursive call as stored in computer memory)  </li>
<li>Set local variables to parameters needed by the procedure and then branch to the beginning of the procedure</li>
</ol>

<p>When exiting from the procedure:</p>

<ol>
<li>Retrieve most recently saved state and restore local variables to the retrieved state  </li>
<li>Retrieve most recently saved 'next instruction address' and branch to address pointed to by the pointer retrieved</li>
</ol>

<p>To this end it can be readily seen why a stack is the most commonly used data structure and in adopting this approach we derive the following:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
  l: if ( node ) {
        visit( node );
        state_stack.push( node );
        next_instruction_stack.push( r );
        node = node-&gt;left;
        goto l;
  r:    node = node-&gt;right;
        goto l;
    }
    if( !state_stack.empty() ) {
        node = state_stack.pop();
        next_instruction = next_instruction_stack.pop();
        goto next_instruction;
    }
}
</code></pre>

<p>The additional <code>if</code> condition relates to exiting from the procedure retrieving and restoring most recently saved state, branch to the retrieved next instruction. The <code>state_stack.empty()</code> condition is triggered towards the completion of the very first invocation of the <code>traverse</code> method. The point to note here is that the placement of this section of the code is such that it appears towards the end of the function.</p>

<p>The label <code>r</code> was initially introduced to specify the address of the instruction address following the recursive call, the derivation above can be dramatically simplified realizing the return instruction is <code>r</code>  throughout therefore altogether removing <code>next_instruction_stack</code>, <code>next_instruction</code> and simply adding a <code>goto r</code>. Simplifying further:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
  l: if ( node ) {
        visit( node );
        state_stack.push( node );
        node = node-&gt;left;
        goto l;
  r:    node = node-&gt;right;
        goto l;
    }
    if( !state_stack.empty() ) {
        node = state_stack.pop();
        goto r;
    }
}
</code></pre>

<p>The recursion now, for all intents and purpose, has been completely removed leaving us with a morass of <code>goto</code>'s forming a rather obfuscated program. These too however can be mechanically removed by identifying that the label <code>r</code>, the subsequent code up until the next <code>goto</code> is effectively surrounded by <code>goto</code>'s therefore simply moving the encapsulated code and eliminating the <code>r</code> label effectively gives us the following:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
  l: if ( node ) {
        visit( node );
        state_stack.push( node );
        node = node-&gt;left;
        goto l;
    }
    if( !state_stack.empty() ) {
        node = state_stack.pop();
        node = node-&gt;right;
        goto l;
    }
}
</code></pre>

<p>We also identify that <code>node</code> is reassigned to <code>node-&gt;right</code> each time it's popped off <code>state_stack</code>, we can simplify this by simply pushing <code>node-&gt;right</code> onto the <code>state_stack</code>.</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
  l: if ( node ) {
        visit( node );
        state_stack.push( node-&gt;right );
        node = node-&gt;left;
        goto l;
    }
    if( !state_stack.empty() ) {
        node = state_stack.pop();
        goto l;
    }
}
</code></pre>

<p>The first <code>if</code> function with the unconditional branch at the end is effectively a <code>while</code> loop and can be written to be as so:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
  l: while ( node ) {
        visit( node );
        state_stack.push( node-&gt;right );
        node = node-&gt;left;
    }
    if( !state_stack.empty() ) {
        node = state_stack.pop();
        goto l;
    }
}
</code></pre>

<p>At the cost of an extra push to the stack, moving the while loop by the addition of an extra label <code>t</code> and a corresponding <code>goto</code> we can transform the above into the following:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
    state_stack.push( node );
 t: if( !state_stack.empty() ) {
        node = state_stack.pop();
        while ( node ) {
            visit( node );
            state_stack.push( node-&gt;right );
            node = node-&gt;left;
        }
        goto t;
    }
}
</code></pre>

<p>The <code>if</code> statement ending with the unconditional branch is the same as we encountered earlier enabling us to change it into a <code>while</code> loop as above eliminating <code>t</code> and it's corresponding <code>goto</code>:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
    state_stack.push( node );
    while( !state_stack.empty() ) {
        node = state_stack.pop();
        while ( node ) {
            visit( node );
            state_stack.push( node-&gt;right );
            node = node-&gt;left;
        }
    }
}
</code></pre>

<p>The <code>while</code> loop within a <code>while</code> loop structure can further be simplified at the cost of additional pushes:</p>

<pre><code class="language- prettyprint lang-cpp">void traverse(Node* node)  
{
    state_stack.push( node );
    while( !state_stack.empty() ) {
        node = state_stack.pop();
        if ( node ) {
            visit( node );
            state_stack.push( node-&gt;right );
            state_stack.push( node-&gt;left );
        }
    }
}
</code></pre>

<p>We end with a concise readable program, completely iterative in nature. The procedure belabored above is one most compilers follow strictly (the points enumerated above), though more complicated in the general case the example above should provide sufficient an insight into compiler design considerations.</p>

<hr>

<p><strong>Note</strong>: in C++ the <code>std::stack</code>'s <code>pop</code> method is a <code>void</code> return type but we chose to include it in this manner from brevity and conciseness. Also the following is omitted:</p>

<pre><code class="language-prettyprint lang-cpp">#include &lt;stack&gt; 
std::stack&lt;Node*&gt; state_stack;  
std::stack&lt;int*&gt; next_instruction_stack;  
int* next_instruction;
</code></pre>
       </section>

        <footer class="post-footer">


            <figure class="author-image">
                <a class="img" href="../author/irfan/" style="background-image: url(../content/images/2015/12/2014-08-24-03-00-45-9dfe7190.png)"><span class="hidden">Irfan Sharif's Picture</span></a>
            </figure>

            <section class="author">
                <h4><a href="../author/irfan/">Irfan Sharif</a></h4>

                    <p>Read <a href="../author/irfan/">more posts</a> by this author.</p>
                <div class="author-meta">
                    <span class="author-location icon-location">canada</span>
                    <span class="author-link icon-link"><a href="http://irfansharif.com">http://irfansharif.com</a></span>
                </div>
            </section>


            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="https://twitter.com/intent/tweet?text=Compilers%20%26%20Recursion&amp;url=http://localhost:2368/compile/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:2368/compile/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=http://localhost:2368/compile/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>

        </footer>
               <div id="disqus_thread"></div>
               <script type="text/javascript">
                    var disqus_shortname = 'irfansharif'; // required: replace example with your forum shortname
                    var disqus_identifier = '';
                 
                    /* * * DON'T EDIT BELOW THIS LINE * * */
                    (function() {
                        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                    })();
                </script>
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>             
 
    </article>
</main>
<aside class="read-next">
    <a class="read-next-story no-cover" href="../lambda-calculus-1/">
        <section class="post">
            <h2>Introduction to Lambda Calculus (Part 1)</h2>
            <p>Alonzo Church's notation for arbitrary functions, $\lambda$-calculus (“lambda calculus”), forms the mathematical foundations for functional programming languages such…</p>
        </section>
    </a>
    <a class="read-next-story prev no-cover" href="../additional-blog-features/">
        <section class="post">
            <h2>Blog Functionality</h2>
            <p>Listed below are the multiple customisations I added to the framework to better suit my purposes. Most directly arise…</p>
        </section>
    </a>
</aside>



        <footer class="site-footer clearfix">
            <section class="copyright"><a href="../">λ</a> © 2016</section>
            <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
        </footer>

    </div>

    <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
    

    <script type="text/javascript" src="../assets/js/jquery.fitvids-39ef717c.js?v=2fcbd9b980"></script>
    <script type="text/javascript" src="../assets/js/index-3c2380eb.js?v=2fcbd9b980"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>  
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">  
            MathJax.Hub.Config({  
                tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']],
                          displayMath: [['$$','$$'], ['\[','\]']]}
            });
    </script>  

        <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'irfansharif'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
        </script>
</body>
